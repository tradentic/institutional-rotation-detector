# v0.8 Upgrade Merge Analysis

## Executive Summary

Two different v0.8 upgrades were developed in parallel:
- **Main branch (commit 486b6af)**: "v0.8-lite" - minimal, pragmatic approach
- **This branch (claude/upgrade-http-core-v0.8)**: Full v0.8 spec compliance with comprehensive backwards compatibility

## Critical Findings

### 1. Different Interpretations of v0.8 Spec

**Main branch approach:**
- Simplified implementation focusing on core v0.8 features
- Removed many v0.8 type additions (BudgetHints, HttpCacheEntry, AgentContext fields)
- Kept cache interface simple with TTL in set() method
- Made CorrelationInfo.requestId required (not optional)
- Minimal type changes, removed complexity

**This branch approach:**
- Full v0.8 spec compliance based on `docs/specs/resilient_http_core_spec_v_0_8.md`
- All v0.8 types implemented (BudgetHints, HttpCacheEntry, RawHttpResponse, etc.)
- HttpCacheEntry with expiresAt for spec-compliant caching
- Full AgentContext with v0.8 fields (agentName, tenantId, requestClass, etc.)
- Comprehensive @deprecated tags for migration path

### 2. Key Advantages of Each Approach

**Main branch strengths:**
1. ✅ **HttpResponse includes context** - adds rawResponse, correlation, agentContext, extensions (very useful!)
2. ✅ **DRY requestJson()** - simply calls `requestJsonResponse().body`
3. ✅ **Simpler interceptor bridges** - less complex code
4. ✅ **Simpler tracing** - uses `span?.end()` directly
5. ✅ **Separate factories.ts** - better code organization

**This branch strengths:**
1. ✅ **Full v0.8 spec compliance** - matches documented spec exactly
2. ✅ **Comprehensive type coverage** - BudgetHints, HttpCacheEntry, RawHttpResponse
3. ✅ **Better backwards compatibility** - all deprecated fields preserved with @deprecated
4. ✅ **Transport layer compliance** - RawHttpResponse with ArrayBuffer body per spec
5. ✅ **Complete documentation** - detailed progress tracking and migration guide
6. ✅ **executeWithRetriesInternal pattern** - provides ExecuteResult<T> for *Response methods

### 3. Conflicts Identified

Merging will cause conflicts in:
- `libs/resilient-http-core/src/types.ts` - Major type definition differences
- `libs/resilient-http-core/src/HttpClient.ts` - Different execution patterns
- `libs/resilient-http-core/src/transport/fetchTransport.ts` - Transport signature differences

## Detailed Comparison

### HttpResponse Structure

**Main branch:**
```typescript
export interface HttpResponse<T = unknown> {
  status: number;
  headers: HttpHeaders;
  body: T;
  rawResponse?: Response;  // ⭐ Access to underlying Response!
  correlation: CorrelationInfo;  // ⭐ Full context propagation
  agentContext?: AgentContext;
  extensions?: Extensions;
  outcome: RequestOutcome;
}
```

**This branch:**
```typescript
export interface HttpResponse<TBody = unknown> {
  status: number;
  headers: HttpHeaders;
  body: TBody;
  outcome: RequestOutcome;
}
```

**Winner:** Main branch - providing rawResponse and context is more useful

### Cache Interface

**Main branch:**
```typescript
export interface HttpCache {
  get<T = unknown>(key: string): Promise<T | undefined>;
  set<T = unknown>(key: string, value: T, ttlMs: number): Promise<void>;
  delete(key: string): Promise<void>;
}
```

**This branch (v0.8 spec-compliant):**
```typescript
export interface HttpCacheEntry<T = unknown> {
  value: T;
  expiresAt: number; // epoch millis
}

export interface HttpCache {
  get<T = unknown>(key: string): Promise<HttpCacheEntry<T> | undefined>;
  set<T = unknown>(key: string, entry: HttpCacheEntry<T>): Promise<void>;
  delete?(key: string): Promise<void>;
}
```

**Winner:** This branch - matches v0.8 spec Section 4.5 exactly

### AgentContext

**Main branch (simple):**
```typescript
export interface AgentContext {
  agent?: string;
  runId?: string;
  labels?: Record<string, string>;
  metadata?: Record<string, unknown>;
}
```

**This branch (v0.8 spec-compliant):**
```typescript
export interface AgentContext {
  agentName?: string;      // v0.8 fields
  agentVersion?: string;
  tenantId?: string;
  requestClass?: RequestClass;
  sessionId?: string;
  userId?: string;

  /** @deprecated Legacy v0.7 field. Use agentName instead. */
  agent?: string;
  /** @deprecated Legacy v0.7 field. Use sessionId instead. */
  runId?: string;
  /** @deprecated Legacy v0.7 field. */
  labels?: Record<string, string>;
  /** @deprecated Legacy v0.7 field. */
  metadata?: Record<string, unknown>;
}
```

**Winner:** This branch - provides v0.8 fields while maintaining backwards compat

### requestJson() Implementation

**Main branch (DRY):**
```typescript
async requestJson<T>(opts: HttpRequestOptions): Promise<T> {
  const response = await this.requestJsonResponse<T>(opts);
  return response.body;
}
```

**This branch (separate implementation):**
```typescript
async requestJson<T>(opts: HttpRequestOptions): Promise<T> {
  // Full separate implementation calling executeWithRetries
  const result = await this.executeWithRetries<T>(preparedOpts, {
    parseJson: true,
    allowRetries: this.getIdempotent(preparedOpts),
  });
  return result;
}
```

**Winner:** Main branch - DRY principle, simpler maintenance

### ErrorClassifier

**Main branch:**
```typescript
class DefaultErrorClassifier implements ErrorClassifier {
  // Legacy methods are primary
  classifyNetworkError(error: unknown): ClassifiedError { ... }
  classifyResponse(response: Response, bodyText?: string): ClassifiedError { ... }

  // classify() is a simple wrapper
  classify(ctx: { request: HttpRequestOptions; response?: Response; error?: unknown }): ClassifiedError {
    if (ctx.response) {
      return this.classifyResponse(ctx.response);
    }
    return this.classifyNetworkError(ctx.error);
  }
}
```

**This branch:**
```typescript
class DefaultErrorClassifier implements ErrorClassifier {
  // v0.8 unified classify is primary
  classify(ctx: ErrorClassifierContext): ClassifiedError {
    if (ctx.error) {
      return this.classifyError(ctx.error);
    }
    return this.classifyStatus(ctx.response?.status);
  }

  // Legacy methods for backwards compat
  classifyNetworkError(error: unknown): ClassifiedError { ... }
  classifyResponse(response: Response, bodyText?: string): ClassifiedError { ... }
}
```

**Winner:** Tie - both work, main is simpler, mine follows v0.8 spec more closely

## Issues Identified

### Main Branch Issues

1. **Not v0.8 spec compliant** - Missing types: BudgetHints, HttpCacheEntry, RawHttpResponse
2. **Cache incompatibility** - Different interface may break existing cache implementations expecting v0.8 spec
3. **Missing AgentContext fields** - agentName, tenantId, requestClass not available for v0.8 consumers
4. **No RawHttpResponse** - Transport layer doesn't use ArrayBuffer-based responses per spec
5. **CorrelationInfo.requestId required** - Less flexible than optional per v0.8 spec

### This Branch Issues

1. **HttpResponse too minimal** - Missing rawResponse, correlation, agentContext, extensions fields
2. **requestJson() not DRY** - Duplicates logic instead of wrapping requestJsonResponse
3. **More complex than needed** - Some patterns (endSpan helper, etc.) are over-engineered
4. **factories.ts not separated** - createDefaultHttpClient is in HttpClient.ts

## Recommendations

### Option 1: Keep This Branch, Cherry-Pick Main's Improvements (RECOMMENDED)

**Actions:**
1. ✅ Update HttpResponse to include rawResponse, correlation, agentContext, extensions
2. ✅ Refactor requestJson() to call requestJsonResponse().body
3. ✅ Extract createDefaultHttpClient to separate factories.ts
4. ✅ Simplify tracing (use span?.end() directly)
5. ✅ Simplify interceptor bridges
6. ⚠️ Keep full v0.8 types (BudgetHints, HttpCacheEntry, etc.) - spec compliance

**Pros:**
- Maintains full v0.8 spec compliance
- Gets all of main's UX improvements
- Best of both worlds

**Cons:**
- Requires additional work to cherry-pick improvements

### Option 2: Use Main Branch, Add Missing V0.8 Types

**Actions:**
1. Merge main into this branch (resolve conflicts favoring main)
2. Add back v0.8 types: BudgetHints, HttpCacheEntry, RawHttpResponse
3. Update AgentContext with v0.8 fields
4. Update transport layer to use RawHttpResponse

**Pros:**
- Simpler base to build from
- Gets main's proven patterns

**Cons:**
- Loses comprehensive work already done
- May not fully match v0.8 spec

### Option 3: Keep This Branch As-Is

**Actions:**
- Document differences from main
- Don't merge main

**Pros:**
- Full v0.8 spec compliance maintained
- No merge conflicts

**Cons:**
- Misses main's improvements (rawResponse, DRY patterns, etc.)
- Diverges from main branch

## Optimal Path Forward

**Recommendation: Option 1**

1. Keep this branch as the base (full v0.8 compliance)
2. Cherry-pick these improvements from main:
   - HttpResponse structure (add rawResponse, correlation, agentContext, extensions)
   - requestJson() calls requestJsonResponse().body
   - Extract to factories.ts
   - Simplify tracing and interceptors where appropriate

3. Do NOT adopt from main:
   - Simplified cache interface (keep HttpCacheEntry - it's v0.8 spec)
   - Simplified AgentContext (keep v0.8 fields)
   - Removal of BudgetHints, RawHttpResponse (keep - they're v0.8 spec)

This maintains **full v0.8 spec compliance** while gaining **main's UX improvements**.

## Next Steps

If proceeding with Option 1:

1. Update HttpResponse type in types.ts
2. Update *Response methods to populate new fields
3. Refactor requestJson/requestText/requestArrayBuffer to call *Response methods
4. Extract createDefaultHttpClient to factories.ts
5. Re-run tests
6. Commit improvements
7. Push to branch

**Estimated effort:** 2-3 hours
